<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GO 语言快速入门 | 酸辣土豆丝 iCS</title>
<meta name=keywords content="tech,golang"><meta name=description content="提供给有编程基础、希望快速了解 Golang 的朋友清晰简洁的基础知识点，帮助他们快速入门这门语言。"><meta name=author content="Spring"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="xkB2VH159BqxPq1aGZjUYzx0I0g7V88UGVtyllS-kD4"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://blog.springx.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.springx.fun/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://blog.springx.fun/favicon.ico><link rel=apple-touch-icon href=https://blog.springx.fun/favicon.ico><link rel=mask-icon href=https://blog.springx.fun/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.springx.fun/posts/tech/golang-quick-guide/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="GO 语言快速入门"><meta property="og:description" content="提供给有编程基础、希望快速了解 Golang 的朋友清晰简洁的基础知识点，帮助他们快速入门这门语言。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.springx.fun/posts/tech/golang-quick-guide/"><meta property="og:image" content="https://blog.springx.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-16T21:47:07+08:00"><meta property="article:modified_time" content="2020-08-16T21:47:07+08:00"><meta property="og:site_name" content="酸辣土豆丝 iCS"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.springx.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="GO 语言快速入门"><meta name=twitter:description content="提供给有编程基础、希望快速了解 Golang 的朋友清晰简洁的基础知识点，帮助他们快速入门这门语言。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.springx.fun/posts/"},{"@type":"ListItem","position":2,"name":"GO 语言快速入门","item":"https://blog.springx.fun/posts/tech/golang-quick-guide/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GO 语言快速入门","name":"GO 语言快速入门","description":"提供给有编程基础、希望快速了解 Golang 的朋友清晰简洁的基础知识点，帮助他们快速入门这门语言。","keywords":["tech","golang"],"articleBody":"00 Go 环境配置 首先，下载 Golang 安装包，地址：https://go.dev/dl/。\n接着，将 Golang 安装包解压到指定路径。\n然后，把 Go 安装路径配置到环境变量。有如下两个环境变量：\nGOROOT：可选，主要是将 $GOROOT/bin 配置到环境变量中以便直接使用 go 命令及其工具等 GOPATH：Go 1.11 之后引入 Go Modules，不再完全依赖 GOPATH 了 Go 1.11 之前，go get 下载的包会被存放在 $GOPATH/src 目录下，与项目无关 Go 1.11 之后（使用了 Go Modules），依赖包会被存放在项目的 go.mod 指定的缓存目录中，默认情况下是 $GOPATH/pkg/mod 01 Go 基础 1.1 变量 类型：放在变量名后面 变量声明：var NAME TYPE 简单变量声明：NAME := VALUE（只允许在函数内部使用，且不能用于声明静态变量） 数据类型 bool string // 不出初始化，则默认空字符串：\"\" int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 // 复数 var x complex128 = complex(1, 2) // 1+2i var y complex128 = complex(3, 4) // 3+4i fmt.Println(x*y) // \"(-5+10i)\" fmt.Println(real(x*y)) // \"-5\" fmt.Println(imag(x*y)) // \"10\" 1.2 循环 Go 只有 for 循环，且格式固定：\n// 没有小括号，大括号必须有 for i := 0; i \u003c 10; i++ { // do ... } // Go 的 while 是 for 的特例 for s \u003c 1000 { // do ... } // 忽略其他条件，死循环，即 while(true) for { // do ... } 1.3 条件判断 Go 的条件判断有 if 和 switch。if 的区别是：\n可以省略小括号 可以有初始语句，类似 for 循环的初始化变量语句 // 可以省略小括号，大括号必须有 if x \u003c 0 { // do } // 还可以有多语句 if v := f(x, n); v \u003c n { // do } Switch 的区别比较大，它只执行单个 case，然后自动 break\n默认 break，如果需要继续执行，则须使用 fallthrough 条件可以为空：相当于 switch true，可以代替很长的 if else switch os := runtime.GOOS; os { case \"darwin\": // do case \"linux\": // do fallthrough default: // do } // if else switch { case x \u003c 0: // if x \u003c 0 case x \u003c 2: // if x \u003c 2 default: // else } 1.4 延迟调用（defer） Go 比 C/Java 多了延迟调用函数 defer。延迟调用的函数的参数会立即计算，但函数在当前函数 return 时（结束）才执行。\ndefer 函数入栈，故多个延迟函数将倒序执行。 另一个作用：配合 recover() 捕获异常。 // x = 1, y = 1 func test(x, y int) int { defer my_defer(\u0026x, y+1) // *param1 = 1, param2 = 2 fmt.Println(\"test: x = \", x) // x = 1，x 的值如果修改，defer 的 x 将同步修改！ return x } 1.5 指针与结构体 Go 有指针，但没有指针运算（C 中的 int *p = \u0026arr; p++; ...）\nvar p *int i := 222 p = \u0026i *p = 22 Go 和 C 一样都有结构体，但它可以指定变量初始化，初始化方式稍微有些差异：\ntype Vertex struct { x, y int } var ( v1 = Vertex{1, 2} v2 = Vertex{y: 3} p = \u0026Vertex{1,1} // p.x == 1, p.y == 1 ) 1.6 切片（Slice） Go 的切片 Slices 和 JavaScript 的 Array 有相似之处\n切片不存储数据，仅指向数组的位置，数组改变切片也会改变。 切片有长度和容量：len(s) and cap(s)（注意左边的取值会影响容量） // 左闭右开区间 primes := [6]int{2, 3, 4, 5, 6} // s = {3, 4, 5} var s []int = primes[1:4] // 可省略左右区间值：左-0，右-length var s = primes[:2] // 2,3 var s = primes[2:] // 4,5,6 var s = primes[:] // 同原数组 fmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s) // 可以看作创建了一个空的数组，s 是指向这个数组的切片，则 s == nil var s []int // 遍历 for INDEX, ELEMENT := range SLICE { // DO... } 动态创建切片，使用 make 预分配空间。在实际使用的过程中，如果容量不够，切片容量会自动扩展\nvar s = make([]int, 5) // len=5 cap=5 [0,0,0,0,0] var s = make([]int, 0, 5) // len=0 cap=5 [] 添加到切片，使用 append 添加/合并，切记不要合并不同的两个切片\n// func append(s []T, vs ...T) []T var s = append(s, 1, 2) // [[s], 1, 2] // Do not do this!!! // 1. 容量不够，会创建新切片 someSlice = append(otherSlice, element) // 2. 容量够，会直接加入，多次创建新的会覆盖旧的 a := make([]int, 3, 8) b := append(a, 5) // b = [0, 0, 0, 5] c := append(a, 6) // b = [0, 0, 0, 6] // c = [0, 0, 0, 5] 1.7 可变参数与展开操作符 Go 没有明确的 Spread Operator 操作符，而 ... 可以将切片展开为可变参数列表\npackage main import \"fmt\" func variadicParam(nums ...int) int { // nums is a slice total := 0 for i := 0; i \u003c len(nums); i++ { total += nums[i] } return total } func main() { // variadic parameter fmt.Printf(\"Sum of any 1: %v\\n\", variadicParam(1, 2, 3)) // 6 // spread operator data := []int{1, 3, 5, 7} fmt.Printf(\"Sum of any 2: %v\\n\", variadicParam(data...)) // 16 } 1.8 范围（range） 在 Go 语言中，range 关键字用于迭代数组、切片、通道（channel）、字符串或映射（map）等数据结构中的元素\nvar pow = []int{1, 2, 4, 8, 16} // 返回：(index, value) for i, v := range pow { // do v = 1, 2, ... } 并且，可以任意忽略索引或者值\nfor i, _ := range pow { // do } for _, v := range pow { // do } // 只要索引 for i := range pow { // do } 1.9 字典（Map） Go 的 Map 与 java 的 HashMap 类似。\n// 1. 仅声明 m := make(map[string]int) // 2. 声明并初始化 m := map[string]string { \"key\": \"value\", } m[\"key\"] = \"haha\" // 3. Map 多层嵌套 m := make(map[string]map[string]int) // m: { // \"first\": { \"v\": 1, ... }, // \"second\": { \"v\": 2, ... }, // } 1.10 枚举 Go 没有枚举类型，可以用 const 定义\ntype：和 typedef 一样 type Gender uint8 const ( MALE Gender = 1 FEMAIL Gender = 0 ) 1.11 错误处理（error） Go 内置 error，类型即为 error：\ntype error interface { Error() string } 自定义错误只需 error.New(\"MSG\") 直接 New 一个错误即可，error 只是一个值，把它看错 C 语言里的 return -1/0/1 就好。\n可以使用 defer 捕获异常，使用 recover 恢复，配合使用达到 try...catch 的效果：\ndefer：延迟函数 recover：程序恢复正常 func get(i int) (ret int) { defer func() { if r := recover(); r != nil { fmt.Println(r) ret = -1 // 程序恢复正常，并且将返回值设置为 -1（不处理默认为 0） } }() y := i / (i - 2) return 22 + y; } fmt.Println(get(2)) // runtime error: integer divide by zero // -1 1.12 函数（func） 函数使用 func 声明：\n格式：func functionName(parameter TYPE) TYPE 特点：可以返回多个参数，无需创建对象/数组再组合返回 // 1. 普通函数 func f1(a int, b int) int {} func f1'(a, b int) int {} // 2. 多返回值 func f2() (string, int) { return \"OK\", 0 } r, ok := f2() r, _ := f2() // 忽略对应值 // 3. 多返回值 - 命名返回变量，自动返回对应值 func f3() (x, y int) { var x int var y int return // 自动返回 x,y } func f3'() (x, y int) { return 1, 2 // 返回值覆盖，x, y 不会被返回 } 1.13 结构体和方法（struct） 结构体和方法的定义 Go 的结构体使用 type NAME struct 定义\n// 定义结构体 type Student struct { name string age int } // 定义方法：下面都可以，如果需要调用该类的字段，则需要声明变量 // * 定义结构体类型：只读 // * 定义结构体指针：可写 // func (Student) hello(person string) string // func (*Student) hello(person string) string func (stu *Student) hello(person string) string { return \"Hello \" + person + \". I am\" + stu.name; } 同时，也可定义匿名结构体\nmyCar := struct { Make string Model string } { Make: \"tesla\", Model: \"model 3\" } // 匿名结构体嵌套 type Car struct { Mkae string Model string Wheel struct { Raidus int Material string } } 结构体的实例化 Go 结构体的实例化有两种方式：\n1 使用 \u0026 直接初始化 2 利用 new s := \u0026Student{ name: \"Tom\", } s := new(Student) s.hello(\"taylor\") 结构体没有继承？ GO 没有继承，但可以使用组合替代\ntype User struct { name string } type Student struct { grade int User } stu := \u0026Student { name: \"Taylor\", grade: 2, } fmt.Println(stu.name) fmt.Println(stu.grade) 1.14 接口（interface） 在 Go 语言中，并不需要显式地声明实现了哪一个接口，只需要直接实现该接口对应的方法即可\n没有 implement 关键字，实例化成对象后，强制类型转换为接口类型（解耦） // 接口 type People interface { getName() string } type Student struct { name string age int } // 实现接口方法 func (s *Student) getName() string { return s.name } v := Student{\"taylor\", 22} stu = \u0026v ftm.Printfln(stu.getName()) // OK stb = v ftm.Printfln(stb.getName()) // ERROR: getName 只在 *Student（指针类型）上定义 接口可以看成是值和类型的元组 (value, type) fmt.Printf(\"(%v, %T)\\n\", stu, stu) // (\u0026{taylor 22}, *main.Student) 空接口表示任意类型 // 1. 接受任何类型的参数 func read(i interface{}) { // do } // 2. Map m := make(map[string]interface{}) m[\"ni\"] = \"hello\" m[\"hao\"] = 22 m[\"a\"] = [2]int{2,2} 1.15 类型判断 断言 x 不为 nil，并且存储在 x 中的值的类型为 TYPE：\nt, ok := x.(TYPE) 首先，基本类型转换，使用对应类型的转换操作即可\nvar x int = 10 var y float64 = float64(x) // 将x转为浮点数 var z int32 = int32(y) // 将y转为32位整数 其次，类型的判断，使用断言表达式：\n返回变量的值和是否匹配状态 如果类型不匹配，并且没有捕获匹配状态，则将报错 var v interface{} = \"hahaha\" s := v.(string) // s = \"hahaha\" s, ok := v.(string) // s = \"hahaha\", ok = true s, ok := v.(float64) // s = 0, ok = false s := v.(float64) // panic 还可以利用 switch case 判断类型\ntype：关键字，仅用于 swatch case。 switch v := i.(type) { case int: // do case string: // do default: // no match; here v has the same type as i } 02 Generics 泛型 2.1 泛型函数 单一泛型比较简单，直接在函数后面声明 [T 类型]，其中 T 为任意名称，类型 可以是具体的内建类型，也可以是自定义的 struct。\nfunc add[T any](a, b T) T { return a + b } func main() { add(1, 2) // 3 add(1.0, 2.2) // 3.2 } 多泛型示例：\n// map func MapKeys[K string, V int](m map[K]V) []K { // do sth. } 2.2 泛型类型及其函数 type Stack[T any] struct { items []T } func (s *Stack[T]) Push(item T) { s.items = append(s.items, item) } func main() { intStack := Stack[int]{} intStack.push(1) intStack.push(2) strStack := Stack[string]{} strStack.push(\"Hello\") strStack.push(\"World\") } 03 Go Modules Go Modules 是 Go 语言用于管理依赖关系的官方解决方案。它的目的是简化和改进 Go 语言项目的依赖管理。\n在早期，Go 使用 GOPATH 来管理依赖包，但这种方式存在一些限制和不便。Go Modules 解决了这些问题，它的关键点包括：\n版本管理 依赖拉取：使用 go get 拉取依赖，不需要依赖于 GOPATH 的特定目录结构 版本控制 代理支持 3.1 创建项目 首先，创建一个空目录，然后使用 go mod init PROJECT 初始化，生成一个 go.mod 文件：\n$ mkdir helloWorld $ cd helloWorld $ go mod init hello $ ls go.mod $ cat go.mod module hello go 1.19.1 然后，添加 main.go，执行编译命令\n$ go build $ ls go.mod hello main.go $ ./hello Hello World~ 接着，使用 go get 安装依赖，这里以 Gin 为例：\n$ go get -u github.com/gin-gonic/gin go: downloading github.com/bytedance/sonic v1.10.2 go: downloading github.com/ugorji/go/codec v1.2.12 go: downloading github.com/go-playground/validator v9.31.0+incompatible go: downloading github.com/go-playground/validator/v10 v10.16.0 ..... $ cat go.mod module hello go 1.21.5 require ( github.com/bytedance/sonic v1.10.2 // indirect github.com/chenzhuoyu/base64x v0.0.0-20230717121745-296ad89f973d // indirect ...... ) 然后，导入依赖，修改程序：\npackage main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func main() { // Create router. r := gin.Default() // Bind. r.GET(\"/\", func(c *gin.Context) { c.String(http.StatusOK, \"Hello World~\") }) // Run \u0026 Serve on 0.0.0.0:8080. r.Run(\":8080\") } 最后，go build 编译后启动服务，使用 curl 校验：\n$ curl http://localhost:8080 Hello World~ 3.2 依赖本地项目（replace） Go Modules 通常都从网上（github.com）拉取依赖，但有时候我们也需要引用到内部其他项目的依赖，需要使用 replace 替换依赖模块的路径。\n一般来说，依赖本地项目仅开发测试使用。\n例如，项目需要依赖 DDD，但是该项目目前只是测试阶段，并未推送到 github，那么可以使用 replace 指定该项目在本机的路径\nmodule example.com/myproject require ( github.com/some/DDD v1.2.3 ) replace github.com/some/DDD v1.2.3 =\u003e /path/to/local/DDD 当然，replace 能替换的东西比较多，本质上就是修改依赖指向，如：\n# 1. 替换版本号 replace github.com/some/DDD v1.2.3 =\u003e replace github.com/some/DDD v1.1.1 # 2. 换源 replace github.com/some/DDD v1.2.3 =\u003e replace mycloud.com/some/DDD v1.1.1 04 Go Channels \u0026 Concurrency 4.1 Goroutines 协程 Goroutine 很简单，使用 go f(x, y, z) 即可异步执行，Goroutine 运行在同一个地址空间，因此对共享内存的访问必须同步。\nfunc f(x, y, z int) { //... } func main() { go f(x, y, z) } 4.2 Channels 管道/通道 通道是一种类型化的管道，您可以通过它使用通道运算符 \u003c- 发送和接收值。\n// Channel 必须先创建 ch := make(chan int) // 向通道发送数据 ch \u003c- v // Send v to channel ch. // 从通道读取数据 v := \u003c-ch // Receive from ch, and // assign value to v. 默认向通道发送和接收数据时阻塞，直到发送/接收完成 从未初始化的通道（nil）读取数据，将死锁 4.3 Buffer Channels 缓冲通道 通道可以缓冲，创建通道时指定缓冲大小即可：\nch := make(chan int, 100) 普通通道默认阻塞，而缓冲通道只会在两种情况下阻塞：\n缓冲通道满时，发送阻塞 缓冲通道为空时，接收阻塞 4.4 Channel Range \u0026 Close 通道可以使用 Range 来遍历接收：\n// v, ok := \u003c- ch // ok is false if ch has closed, or it is true ch := make(chan int, 10) // 这里只推送了 5 个，所以需要主动关闭通道 go f(5, ch) for i := range ch { // print } 发送者可以主动关闭通道（接收者不行）， 当然，通道和文件不同，通常不用关闭。\nfunc f(n int, ch chan int) { for i := 0; i \u003c n; i++ { ch \u003c- i + 1 } // 关闭 ch，以防 x 小于 ch 缓冲长度 close(ch) } 4.5 Select 多通道监听 上述 Channel 和 Buffer Channel 都是针对单个通道的，如果要同时接收多个通道的信息，需要使用 Select，它类似 switch 语法，只不过它用于通道监听。\nfor { select { case i, ok := \u003c- ch1: // do sth. case j, ok := \u003c- ch2: // do sth. } } 当 Select 监听的其中一个通道接收到数据，对执行对应的 case；如果同时多个通道都接收到消息，那么会随机选择一个（是不是有点类似 C 的 select、poll、epoll？）\nSelect 默认是阻塞等待的，但是加上 default 之后，它就变成类似 try lock 的非阻塞监听，通道有数据时读取，如果没有直接往下执行：\nselect { case i, ok := \u003c- ch // do sth. default: // 从 ch 接收时会阻塞 } 4.6 只读、只写限制 声明 Channel 时，可以限制它的读写权限：\n\u003c-chan T：只读通道 chan\u003c- T：只写通道 func readOnly(ch \u003c-chan int) { // ch can only be read from. } func wirteOnly(ch chan\u003c- int) { // ch can only be write to. } func main() { ch := make(chan int) writeOnly(ch) readOnly(ch) } 05 锁 5.1 Mutex 互斥锁 互斥锁（Mutex，全称 Mutual Exclusion）是一种同步机制，用于确保在任意时刻只有一个线程能够访问共享资源，从而避免多个线程同时修改相同的数据造成的问题。\nMutex 有如下两个方法：\nsync.Lock()：加锁 sync.Unlock()：解锁 import ( \"sync\" ) var sharedResource int var mutex sync.Mutex func inc() { // 加锁 mutex.Lock() defer mutex.Unlock() // 在函数结束时释放锁 // 访问或修改共享资源 sharedResource++ // ... } func main() { // go inc() ... } 5.2 RWMutex 读写锁 RWMutex 读写互斥锁，它相比于普通的互斥锁 Mutex 提供了更灵活的读写控制。在 Go 语言中，RWMutex 可以同时允许多个 goroutine 获取读取锁，但在写入锁被获取时，所有的读取和写入操作都会被阻塞。\n除了有 Mutex 一样的 Lock 和 Unlock 方法，还有读写锁：\nsync.RLock()：加读锁，多个 goroutine 可同时加锁，不影响读。但如果被 Lock，则 RLock 不能再加锁，将被阻塞 sync.RUnlock()：解锁 REFERENCES [1] 官方文档. https://tour.golang.org/.\n[2] 极客兔兔. Go 语言简明教程[DB/OL]. https://geektutu.com/post/quick-golang.html.\n","wordCount":"1918","inLanguage":"en","image":"https://blog.springx.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2020-08-16T21:47:07+08:00","dateModified":"2020-08-16T21:47:07+08:00","author":[{"@type":"Person","name":"Spring"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.springx.fun/posts/tech/golang-quick-guide/"},"publisher":{"@type":"Organization","name":"酸辣土豆丝 iCS","logo":{"@type":"ImageObject","url":"https://blog.springx.fun/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.springx.fun/ accesskey=h title="酸辣土豆丝 iCS (Alt + H)"><img src=https://blog.springx.fun/potato-64.jpg alt aria-label=logo height=35>酸辣土豆丝 iCS</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.springx.fun/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.springx.fun/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.springx.fun/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.springx.fun/>Home</a>&nbsp;»&nbsp;<a href=https://blog.springx.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">GO 语言快速入门</h1><div class=post-description>提供给有编程基础、希望快速了解 Golang 的朋友清晰简洁的基础知识点，帮助他们快速入门这门语言。</div><div class=post-meta><span title='2020-08-16 21:47:07 +0800 CST'>August 16, 2020</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1918 words&nbsp;·&nbsp;Spring&nbsp;|&nbsp;<a href=https://github.com/heyzqq/heyzqq-content.github.io/tree/main/content/posts/tech/golang-quick-guide.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#00-go-环境配置>00 Go 环境配置</a></li><li><a href=#01-go-基础>01 Go 基础</a><ul><li><a href=#11-变量>1.1 变量</a></li><li><a href=#12-循环>1.2 循环</a></li><li><a href=#13-条件判断>1.3 条件判断</a></li><li><a href=#14-延迟调用defer>1.4 延迟调用（defer）</a></li><li><a href=#15-指针与结构体>1.5 指针与结构体</a></li><li><a href=#16-切片slice>1.6 切片（Slice）</a></li><li><a href=#17-可变参数与展开操作符>1.7 可变参数与展开操作符</a></li><li><a href=#18-范围range>1.8 范围（range）</a></li><li><a href=#19-字典map>1.9 字典（Map）</a></li><li><a href=#110-枚举>1.10 枚举</a></li><li><a href=#111-错误处理error>1.11 错误处理（error）</a></li><li><a href=#112-函数func>1.12 函数（func）</a></li><li><a href=#113-结构体和方法struct>1.13 结构体和方法（struct）</a></li><li><a href=#114-接口interface>1.14 接口（interface）</a></li><li><a href=#115-类型判断>1.15 类型判断</a></li></ul></li><li><a href=#02-generics-泛型>02 Generics 泛型</a><ul><li><a href=#21-泛型函数>2.1 泛型函数</a></li><li><a href=#22-泛型类型及其函数>2.2 泛型类型及其函数</a></li></ul></li><li><a href=#03-go-modules>03 Go Modules</a><ul><li><a href=#31-创建项目>3.1 创建项目</a></li><li><a href=#32-依赖本地项目replace>3.2 依赖本地项目（replace）</a></li></ul></li><li><a href=#04-go-channels--concurrency>04 Go Channels & Concurrency</a><ul><li><a href=#41-goroutines-协程>4.1 Goroutines 协程</a></li><li><a href=#42-channels-管道通道>4.2 Channels 管道/通道</a></li><li><a href=#43-buffer-channels-缓冲通道>4.3 Buffer Channels 缓冲通道</a></li><li><a href=#44-channel-range--close>4.4 Channel Range & Close</a></li><li><a href=#45-select-多通道监听>4.5 Select 多通道监听</a></li><li><a href=#46-只读只写限制>4.6 只读、只写限制</a></li></ul></li><li><a href=#05-锁>05 锁</a><ul><li><a href=#51-mutex-互斥锁>5.1 Mutex 互斥锁</a></li><li><a href=#52-rwmutex-读写锁>5.2 RWMutex 读写锁</a></li></ul></li><li><a href=#references>REFERENCES</a></li></ul></nav></div></details></div><div class=post-content><h2 id=00-go-环境配置>00 Go 环境配置<a hidden class=anchor aria-hidden=true href=#00-go-环境配置>#</a></h2><p>首先，下载 Golang 安装包，地址：https://go.dev/dl/。</p><p>接着，将 Golang 安装包解压到指定路径。</p><p>然后，把 Go 安装路径配置到环境变量。有如下两个环境变量：</p><ul><li>GOROOT：可选，主要是将 <code>$GOROOT/bin</code> 配置到环境变量中以便直接使用 go 命令及其工具等</li><li>GOPATH：Go 1.11 之后引入 Go Modules，不再完全依赖 <code>GOPATH</code> 了<ul><li>Go 1.11 之前，<code>go get</code> 下载的包会被存放在 <code>$GOPATH/src</code> 目录下，与项目无关</li><li>Go 1.11 之后（使用了 Go Modules），依赖包会被存放在项目的 <code>go.mod</code> 指定的缓存目录中，默认情况下是 <code>$GOPATH/pkg/mod</code></li></ul></li></ul><h2 id=01-go-基础>01 Go 基础<a hidden class=anchor aria-hidden=true href=#01-go-基础>#</a></h2><h3 id=11-变量>1.1 变量<a hidden class=anchor aria-hidden=true href=#11-变量>#</a></h3><ol><li>类型：放在变量名后面</li><li>变量声明：<code>var NAME TYPE</code></li><li>简单变量声明：<code>NAME := VALUE</code>（只允许在函数内部使用，且不能用于声明静态变量）</li><li>数据类型</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>string</span>  <span class=c1>// 不出初始化，则默认空字符串：&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span>  <span class=kt>int8</span>  <span class=kt>int16</span>  <span class=kt>int32</span>  <span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=kt>uint</span> <span class=kt>uint8</span> <span class=kt>uint16</span> <span class=kt>uint32</span> <span class=kt>uint64</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>byte</span> <span class=c1>// alias for uint8
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>rune</span> <span class=c1>// alias for int32
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=c1>// represents a Unicode code point
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>float32</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>complex64</span> <span class=kt>complex128</span> <span class=c1>// 复数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>x</span> <span class=kt>complex128</span> <span class=p>=</span> <span class=nb>complex</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=c1>// 1+2i
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>y</span> <span class=kt>complex128</span> <span class=p>=</span> <span class=nb>complex</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=c1>// 3+4i
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=o>*</span><span class=nx>y</span><span class=p>)</span>                 <span class=c1>// &#34;(-5+10i)&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>real</span><span class=p>(</span><span class=nx>x</span><span class=o>*</span><span class=nx>y</span><span class=p>))</span>           <span class=c1>// &#34;-5&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>imag</span><span class=p>(</span><span class=nx>x</span><span class=o>*</span><span class=nx>y</span><span class=p>))</span>           <span class=c1>// &#34;10&#34;
</span></span></span></code></pre></div><h3 id=12-循环>1.2 循环<a hidden class=anchor aria-hidden=true href=#12-循环>#</a></h3><p>Go 只有 <code>for</code> 循环，且格式固定：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 没有小括号，大括号必须有
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Go 的 while 是 for 的特例
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>s</span> <span class=p>&lt;</span> <span class=mi>1000</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 忽略其他条件，死循环，即 while(true)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=13-条件判断>1.3 条件判断<a hidden class=anchor aria-hidden=true href=#13-条件判断>#</a></h3><p>Go 的条件判断有 <code>if</code> 和 <code>switch</code>。<code>if</code> 的区别是：</p><ol><li>可以省略小括号</li><li>可以有初始语句，类似 <code>for</code> 循环的初始化变量语句</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 可以省略小括号，大括号必须有
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>x</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 还可以有多语句
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>v</span> <span class=o>:=</span> <span class=nf>f</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>n</span><span class=p>);</span> <span class=nx>v</span> <span class=p>&lt;</span> <span class=nx>n</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>Switch</code> 的区别比较大，它只执行单个 <code>case</code>，然后自动 <code>break</code></p><ul><li>默认 <code>break</code>，如果需要继续执行，则须使用 <code>fallthrough</code></li><li>条件可以为空：相当于 <code>switch true</code>，可以代替很长的 <code>if else</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>switch</span> <span class=nx>os</span> <span class=o>:=</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>GOOS</span><span class=p>;</span> <span class=nx>os</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=s>&#34;darwin&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=s>&#34;linux&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>fallthrough</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// if else
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>x</span> <span class=p>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// if x &lt; 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=nx>x</span> <span class=p>&lt;</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// if x &lt; 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// else
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=14-延迟调用defer>1.4 延迟调用（defer）<a hidden class=anchor aria-hidden=true href=#14-延迟调用defer>#</a></h3><p>Go 比 C/Java 多了延迟调用函数 <code>defer</code>。延迟调用的函数的<strong>参数</strong>会立即计算，但函数在当前函数 <code>return</code> 时（结束）才执行。</p><ul><li><code>defer</code> 函数入栈，故多个延迟函数将<strong>倒序</strong>执行。</li><li>另一个作用：配合 <code>recover()</code> 捕获异常。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// x = 1, y = 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>test</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nf>my_defer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>         <span class=c1>// *param1 = 1, param2 = 2
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;test: x = &#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>    <span class=c1>// x = 1，x 的值如果修改，defer 的 x 将同步修改！
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=15-指针与结构体>1.5 指针与结构体<a hidden class=anchor aria-hidden=true href=#15-指针与结构体>#</a></h3><p>Go 有指针，但没有指针运算（C 中的 <code>int *p = &amp;arr; p++; ...</code>）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>p</span> <span class=o>*</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nx>i</span> <span class=o>:=</span> <span class=mi>222</span>
</span></span><span class=line><span class=cl><span class=nx>p</span>  <span class=p>=</span> <span class=o>&amp;</span><span class=nx>i</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=nx>p</span> <span class=p>=</span> <span class=mi>22</span>
</span></span></code></pre></div><p>Go 和 C 一样都有结构体，但它可以指定变量初始化，初始化方式稍微有些差异：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Vertex</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>v1</span> <span class=p>=</span> <span class=nx>Vertex</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>v2</span> <span class=p>=</span> <span class=nx>Vertex</span><span class=p>{</span><span class=nx>y</span><span class=p>:</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>p</span>  <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Vertex</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>}</span>  <span class=c1>// p.x == 1, p.y == 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span></code></pre></div><h3 id=16-切片slice>1.6 切片（Slice）<a hidden class=anchor aria-hidden=true href=#16-切片slice>#</a></h3><p>Go 的切片 <code>Slices</code> 和 JavaScript 的 Array 有相似之处</p><ul><li>切片不存储数据，仅指向数组的位置，数组改变切片也会改变。</li><li>切片有长度和容量：<code>len(s)</code> and <code>cap(s)</code>（注意左边的取值会影响容量）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 左闭右开区间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>primes</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>6</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// s = {3, 4, 5}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>=</span> <span class=nx>primes</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 可省略左右区间值：左-0，右-length
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s</span> <span class=p>=</span> <span class=nx>primes</span><span class=p>[:</span><span class=mi>2</span><span class=p>]</span> <span class=c1>// 2,3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s</span> <span class=p>=</span> <span class=nx>primes</span><span class=p>[</span><span class=mi>2</span><span class=p>:]</span> <span class=c1>// 4,5,6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s</span> <span class=p>=</span> <span class=nx>primes</span><span class=p>[:]</span>  <span class=c1>// 同原数组
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;len=%d cap=%d %v\n&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 可以看作创建了一个空的数组，s 是指向这个数组的切片，则 s == nil
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 遍历
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>INDEX</span><span class=p>,</span> <span class=nx>ELEMENT</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>SLICE</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// DO...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>动态创建切片，使用 <code>make</code> 预分配空间。在实际使用的过程中，如果容量不够，切片容量会自动扩展</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>    <span class=c1>// len=5 cap=5 [0,0,0,0,0]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=c1>// len=0 cap=5 []
</span></span></span></code></pre></div><p>添加到切片，使用 <code>append</code> 添加/合并，切记不要合并不同的两个切片</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// func append(s []T, vs ...T) []T
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>      <span class=c1>// [[s], 1, 2]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Do not do this!!!
</span></span></span><span class=line><span class=cl><span class=c1>// 1. 容量不够，会创建新切片
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>someSlice</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>otherSlice</span><span class=p>,</span> <span class=nx>element</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 2. 容量够，会直接加入，多次创建新的会覆盖旧的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=c1>// b = [0, 0, 0, 5]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>c</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span> <span class=c1>// b = [0, 0, 0, 6]
</span></span></span><span class=line><span class=cl><span class=c1></span>                  <span class=c1>// c = [0, 0, 0, 5]
</span></span></span></code></pre></div><h3 id=17-可变参数与展开操作符>1.7 可变参数与展开操作符<a hidden class=anchor aria-hidden=true href=#17-可变参数与展开操作符>#</a></h3><p>Go 没有明确的 Spread Operator 操作符，而 <code>...</code> 可以将切片展开为可变参数列表</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>variadicParam</span><span class=p>(</span><span class=nx>nums</span> <span class=o>...</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// nums is a slice
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>total</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>total</span> <span class=o>+=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>total</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// variadic parameter
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Sum of any 1: %v\n&#34;</span><span class=p>,</span> <span class=nf>variadicParam</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span> <span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// spread operator
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Sum of any 2: %v\n&#34;</span><span class=p>,</span> <span class=nf>variadicParam</span><span class=p>(</span><span class=nx>data</span><span class=o>...</span><span class=p>))</span> <span class=c1>// 16
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=18-范围range>1.8 范围（range）<a hidden class=anchor aria-hidden=true href=#18-范围range>#</a></h3><p>在 Go 语言中，range 关键字用于迭代数组、切片、通道（channel）、字符串或映射（map）等数据结构中的元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>pow</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>16</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回：(index, value)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pow</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do v = 1, 2, ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>并且，可以任意忽略索引或者值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pow</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pow</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 只要索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pow</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=19-字典map>1.9 字典（Map）<a hidden class=anchor aria-hidden=true href=#19-字典map>#</a></h3><p>Go 的 Map 与 java 的 HashMap 类似。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 1. 仅声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 2. 声明并初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;key&#34;</span><span class=p>:</span> <span class=s>&#34;value&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>[</span><span class=s>&#34;key&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;haha&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 3. Map 多层嵌套
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// m: {
</span></span></span><span class=line><span class=cl><span class=c1>//     &#34;first&#34;: { &#34;v&#34;: 1, ... },
</span></span></span><span class=line><span class=cl><span class=c1>//     &#34;second&#34;: { &#34;v&#34;: 2, ... },
</span></span></span><span class=line><span class=cl><span class=c1>// }
</span></span></span></code></pre></div><h3 id=110-枚举>1.10 枚举<a hidden class=anchor aria-hidden=true href=#110-枚举>#</a></h3><p>Go 没有枚举类型，可以用 <code>const</code> 定义</p><ul><li><code>type</code>：和 <code>typedef</code> 一样</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Gender</span> <span class=kt>uint8</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>MALE</span>   <span class=nx>Gender</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>FEMAIL</span> <span class=nx>Gender</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><h3 id=111-错误处理error>1.11 错误处理（error）<a hidden class=anchor aria-hidden=true href=#111-错误处理error>#</a></h3><p>Go 内置 <code>error</code>，类型即为 <code>error</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=kt>error</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Error</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>自定义错误只需 <code>error.New("MSG")</code> 直接 New 一个错误即可，<code>error</code> 只是一个值，把它看错 C 语言里的 <code>return -1/0/1</code> 就好。</p><p>可以使用 <code>defer</code> 捕获异常，使用 <code>recover</code> 恢复，配合使用达到 <code>try...catch</code> 的效果：</p><ul><li><code>defer</code>：延迟函数</li><li><code>recover</code>：程序恢复正常</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>get</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>ret</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>r</span> <span class=o>:=</span> <span class=nb>recover</span><span class=p>();</span> <span class=nx>r</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>ret</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>  <span class=c1>// 程序恢复正常，并且将返回值设置为 -1（不处理默认为 0）
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=nx>y</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>/</span> <span class=p>(</span><span class=nx>i</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>22</span> <span class=o>+</span> <span class=nx>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>get</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1>// runtime error: integer divide by zero
</span></span></span><span class=line><span class=cl><span class=c1>// -1
</span></span></span></code></pre></div><h3 id=112-函数func>1.12 函数（func）<a hidden class=anchor aria-hidden=true href=#112-函数func>#</a></h3><p>函数使用 <code>func</code> 声明：</p><ul><li>格式：<code>func functionName(parameter TYPE) TYPE</code></li><li>特点：可以返回多个参数，无需创建对象/数组再组合返回</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 1. 普通函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>f1</span><span class=p>(</span><span class=nx>a</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>f1</span><span class=err>&#39;</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 2. 多返回值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>f2</span><span class=p>()</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=s>&#34;OK&#34;</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>r</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nf>f2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>r</span><span class=p>,</span> <span class=nx>_</span>  <span class=o>:=</span> <span class=nf>f2</span><span class=p>()</span> <span class=c1>// 忽略对应值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 3. 多返回值 - 命名返回变量，自动返回对应值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>f3</span><span class=p>()</span> <span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kd>var</span> <span class=nx>x</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>   <span class=kd>var</span> <span class=nx>y</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=c1>// 自动返回 x,y
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>f3</span><span class=err>&#39;</span><span class=p>()</span> <span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span>  <span class=c1>// 返回值覆盖，x, y 不会被返回
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=113-结构体和方法struct>1.13 结构体和方法（struct）<a hidden class=anchor aria-hidden=true href=#113-结构体和方法struct>#</a></h3><h4 id=结构体和方法的定义>结构体和方法的定义<a hidden class=anchor aria-hidden=true href=#结构体和方法的定义>#</a></h4><p>Go 的结构体使用 <code>type NAME struct</code> 定义</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 定义结构体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Student</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>age</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 定义方法：下面都可以，如果需要调用该类的字段，则需要声明变量
</span></span></span><span class=line><span class=cl><span class=c1>//      * 定义结构体类型：只读
</span></span></span><span class=line><span class=cl><span class=c1>//      * 定义结构体指针：可写
</span></span></span><span class=line><span class=cl><span class=c1>// func (Student) hello(person string) string
</span></span></span><span class=line><span class=cl><span class=c1>// func (*Student) hello(person string) string
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>stu</span> <span class=o>*</span><span class=nx>Student</span><span class=p>)</span> <span class=nf>hello</span><span class=p>(</span><span class=nx>person</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s>&#34;Hello &#34;</span> <span class=o>+</span> <span class=nx>person</span> <span class=o>+</span> <span class=s>&#34;. I am&#34;</span> <span class=o>+</span> <span class=nx>stu</span><span class=p>.</span><span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>同时，也可定义匿名结构体</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GO data-lang=GO><span class=line><span class=cl><span class=nx>myCar</span> <span class=o>:=</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Make</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>Model</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Make</span><span class=p>:</span> <span class=s>&#34;tesla&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Model</span><span class=p>:</span> <span class=s>&#34;model 3&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 匿名结构体嵌套
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Car</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Mkae</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>Model</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>Wheel</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Raidus</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>        <span class=nx>Material</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=结构体的实例化>结构体的实例化<a hidden class=anchor aria-hidden=true href=#结构体的实例化>#</a></h4><p>Go 结构体的实例化有两种方式：</p><ul><li>1 使用 <code>&</code> 直接初始化</li><li>2 利用 <code>new</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Student</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>name</span><span class=p>:</span> <span class=s>&#34;Tom&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Student</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>s</span><span class=p>.</span><span class=nf>hello</span><span class=p>(</span><span class=s>&#34;taylor&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=结构体没有继承>结构体没有继承？<a hidden class=anchor aria-hidden=true href=#结构体没有继承>#</a></h4><p>GO 没有继承，但可以使用组合替代</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>User</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Student</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>grade</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>User</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>stu</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>name</span><span class=p>:</span> <span class=s>&#34;Taylor&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>grade</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>stu</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>stu</span><span class=p>.</span><span class=nx>grade</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=114-接口interface>1.14 接口（interface）<a hidden class=anchor aria-hidden=true href=#114-接口interface>#</a></h3><p>在 Go 语言中，并不需要显式地声明实现了哪一个接口，只需要<strong>直接实现</strong>该接口对应的方法即可</p><ul><li>没有 <code>implement</code> 关键字，实例化成对象后，强制类型转换为接口类型（解耦）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>People</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>getName</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Student</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>age</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 实现接口方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Student</span><span class=p>)</span> <span class=nf>getName</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nx>name</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>v</span> <span class=o>:=</span> <span class=nx>Student</span><span class=p>{</span><span class=s>&#34;taylor&#34;</span><span class=p>,</span> <span class=mi>22</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>stu</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>v</span>
</span></span><span class=line><span class=cl><span class=nx>ftm</span><span class=p>.</span><span class=nf>Printfln</span><span class=p>(</span><span class=nx>stu</span><span class=p>.</span><span class=nf>getName</span><span class=p>())</span>  <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>stb</span> <span class=p>=</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl><span class=nx>ftm</span><span class=p>.</span><span class=nf>Printfln</span><span class=p>(</span><span class=nx>stb</span><span class=p>.</span><span class=nf>getName</span><span class=p>())</span>  <span class=c1>// ERROR: getName 只在 *Student（指针类型）上定义
</span></span></span></code></pre></div><ul><li>接口可以看成是值和类型的元组<ul><li><code>(value, type)</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;(%v, %T)\n&#34;</span><span class=p>,</span> <span class=nx>stu</span><span class=p>,</span> <span class=nx>stu</span><span class=p>)</span>  <span class=c1>// (&amp;{taylor 22}, *main.Student)
</span></span></span></code></pre></div></li><li>空接口表示任意类型<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 1. 接受任何类型的参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>read</span><span class=p>(</span><span class=nx>i</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 2. Map
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>[</span><span class=s>&#34;ni&#34;</span><span class=p>]</span>  <span class=p>=</span> <span class=s>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>[</span><span class=s>&#34;hao&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=mi>22</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>[</span><span class=s>&#34;a&#34;</span><span class=p>]</span>   <span class=p>=</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span><span class=mi>2</span><span class=p>}</span>
</span></span></code></pre></div></li></ul><h3 id=115-类型判断>1.15 类型判断<a hidden class=anchor aria-hidden=true href=#115-类型判断>#</a></h3><p>断言 x 不为 <code>nil</code>，并且存储在 x 中的值的类型为 <code>TYPE</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>t</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>x</span><span class=p>.(</span><span class=nx>TYPE</span><span class=p>)</span>
</span></span></code></pre></div><p>首先，基本类型转换，使用对应类型的转换操作即可</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>x</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>y</span> <span class=kt>float64</span> <span class=p>=</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=c1>// 将x转为浮点数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>z</span> <span class=kt>int32</span> <span class=p>=</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>y</span><span class=p>)</span> <span class=c1>// 将y转为32位整数
</span></span></span></code></pre></div><p>其次，类型的判断，使用断言表达式：</p><ul><li>返回变量的值和是否匹配状态</li><li>如果类型不匹配，并且没有捕获匹配状态，则将报错</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>=</span> <span class=s>&#34;hahaha&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=nx>v</span><span class=p>.(</span><span class=kt>string</span><span class=p>)</span>         <span class=c1>// s = &#34;hahaha&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>v</span><span class=p>.(</span><span class=kt>string</span><span class=p>)</span>     <span class=c1>// s = &#34;hahaha&#34;, ok = true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>v</span><span class=p>.(</span><span class=kt>float64</span><span class=p>)</span>    <span class=c1>// s = 0, ok = false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s</span> <span class=o>:=</span> <span class=nx>v</span><span class=p>.(</span><span class=kt>float64</span><span class=p>)</span>        <span class=c1>// panic
</span></span></span></code></pre></div><p>还可以利用 <code>switch case</code> 判断类型</p><ul><li><code>type</code>：关键字，仅用于 <code>swatch case</code>。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>switch</span> <span class=nx>v</span> <span class=o>:=</span> <span class=nx>i</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=kt>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=kt>string</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// no match; here v has the same type as i
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=02-generics-泛型>02 Generics 泛型<a hidden class=anchor aria-hidden=true href=#02-generics-泛型>#</a></h2><h3 id=21-泛型函数>2.1 泛型函数<a hidden class=anchor aria-hidden=true href=#21-泛型函数>#</a></h3><p>单一泛型比较简单，直接在函数后面声明 <code>[T 类型]</code>，其中 <code>T</code> 为任意名称，<code>类型</code> 可以是具体的内建类型，也可以是自定义的 struct。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nx>add</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>](</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=nx>T</span><span class=p>)</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>add</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>2.2</span><span class=p>)</span> <span class=c1>// 3.2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>多泛型示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// map
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nx>MapKeys</span><span class=p>[</span><span class=nx>K</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>V</span> <span class=kt>int</span><span class=p>](</span><span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=nx>K</span><span class=p>]</span><span class=nx>V</span><span class=p>)</span> <span class=p>[]</span><span class=nx>K</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do sth.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=22-泛型类型及其函数>2.2 泛型类型及其函数<a hidden class=anchor aria-hidden=true href=#22-泛型类型及其函数>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Stack</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>items</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Stack</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>item</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span><span class=p>.</span><span class=nx>items</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>items</span><span class=p>,</span> <span class=nx>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>intStack</span> <span class=o>:=</span> <span class=nx>Stack</span><span class=p>[</span><span class=kt>int</span><span class=p>]{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>intStack</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>intStack</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>strStack</span> <span class=o>:=</span> <span class=nx>Stack</span><span class=p>[</span><span class=kt>string</span><span class=p>]{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>strStack</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>strStack</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=s>&#34;World&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=03-go-modules>03 Go Modules<a hidden class=anchor aria-hidden=true href=#03-go-modules>#</a></h2><p>Go Modules 是 Go 语言用于管理依赖关系的官方解决方案。它的目的是简化和改进 Go 语言项目的依赖管理。</p><p>在早期，Go 使用 GOPATH 来管理依赖包，但这种方式存在一些限制和不便。Go Modules 解决了这些问题，它的关键点包括：</p><ul><li>版本管理</li><li>依赖拉取：使用 <code>go get</code> 拉取依赖，不需要依赖于 <code>GOPATH</code> 的特定目录结构</li><li>版本控制</li><li>代理支持</li></ul><h3 id=31-创建项目>3.1 创建项目<a hidden class=anchor aria-hidden=true href=#31-创建项目>#</a></h3><p>首先，创建一个空目录，然后使用 <code>go mod init PROJECT</code> 初始化，生成一个 <code>go.mod</code> 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mkdir helloWorld
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> helloWorld
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ go mod init hello
</span></span><span class=line><span class=cl>$ ls
</span></span><span class=line><span class=cl>go.mod
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ cat go.mod                      
</span></span><span class=line><span class=cl>module hello
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>go 1.19.1
</span></span></code></pre></div><p>然后，添加 <code>main.go</code>，执行编译命令</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go build
</span></span><span class=line><span class=cl>$ ls
</span></span><span class=line><span class=cl>go.mod  hello  main.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ./hello
</span></span><span class=line><span class=cl>Hello World~
</span></span></code></pre></div><p>接着，使用 <code>go get</code> 安装依赖，这里以 Gin 为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=err>$</span> <span class=k>go</span> <span class=nx>get</span> <span class=o>-</span><span class=nx>u</span> <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>gin</span><span class=o>-</span><span class=nx>gonic</span><span class=o>/</span><span class=nx>gin</span>
</span></span><span class=line><span class=cl><span class=k>go</span><span class=p>:</span> <span class=nx>downloading</span> <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>bytedance</span><span class=o>/</span><span class=nx>sonic</span> <span class=nx>v1</span><span class=mf>.10.2</span>
</span></span><span class=line><span class=cl><span class=k>go</span><span class=p>:</span> <span class=nx>downloading</span> <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>ugorji</span><span class=o>/</span><span class=k>go</span><span class=o>/</span><span class=nx>codec</span> <span class=nx>v1</span><span class=mf>.2.12</span>
</span></span><span class=line><span class=cl><span class=k>go</span><span class=p>:</span> <span class=nx>downloading</span> <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=k>go</span><span class=o>-</span><span class=nx>playground</span><span class=o>/</span><span class=nx>validator</span> <span class=nx>v9</span><span class=mf>.31.0</span><span class=o>+</span><span class=nx>incompatible</span>
</span></span><span class=line><span class=cl><span class=k>go</span><span class=p>:</span> <span class=nx>downloading</span> <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=k>go</span><span class=o>-</span><span class=nx>playground</span><span class=o>/</span><span class=nx>validator</span><span class=o>/</span><span class=nx>v10</span> <span class=nx>v10</span><span class=mf>.16.0</span>
</span></span><span class=line><span class=cl><span class=o>...</span><span class=p>..</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>$</span> <span class=nx>cat</span> <span class=k>go</span><span class=p>.</span><span class=nx>mod</span> 
</span></span><span class=line><span class=cl><span class=nx>module</span> <span class=nx>hello</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=mf>1.21.5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>require</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>bytedance</span><span class=o>/</span><span class=nx>sonic</span> <span class=nx>v1</span><span class=mf>.10.2</span> <span class=c1>// indirect
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>chenzhuoyu</span><span class=o>/</span><span class=nx>base64x</span> <span class=nx>v0</span><span class=mf>.0.0</span><span class=o>-</span><span class=mi>20230717121745</span><span class=o>-</span><span class=mi>296</span><span class=nx>ad89f973d</span> <span class=c1>// indirect
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>......</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>然后，导入依赖，修改程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/gin-gonic/gin&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create router.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>r</span> <span class=o>:=</span> <span class=nx>gin</span><span class=p>.</span><span class=nf>Default</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Bind.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>r</span><span class=p>.</span><span class=nf>GET</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusOK</span><span class=p>,</span> <span class=s>&#34;Hello World~&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Run &amp; Serve on 0.0.0.0:8080.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>r</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最后，<code>go build</code> 编译后启动服务，使用 curl 校验：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ curl http://localhost:8080
</span></span><span class=line><span class=cl>Hello World~
</span></span></code></pre></div><h3 id=32-依赖本地项目replace>3.2 依赖本地项目（replace）<a hidden class=anchor aria-hidden=true href=#32-依赖本地项目replace>#</a></h3><p>Go Modules 通常都从网上（github.com）拉取依赖，但有时候我们也需要引用到内部其他项目的依赖，需要使用 <code>replace</code> 替换依赖模块的路径。</p><p>一般来说，依赖本地项目仅开发测试使用。</p><p>例如，项目需要依赖 DDD，但是该项目目前只是测试阶段，并未推送到 github，那么可以使用 <code>replace</code> 指定该项目在本机的路径</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>module example.com/myproject
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>require <span class=o>(</span>
</span></span><span class=line><span class=cl>    github.com/some/DDD v1.2.3
</span></span><span class=line><span class=cl><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>replace github.com/some/DDD v1.2.3 <span class=o>=</span>&gt; /path/to/local/DDD
</span></span></code></pre></div><p>当然，<code>replace</code> 能替换的东西比较多，本质上就是修改依赖指向，如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 1. 替换版本号</span>
</span></span><span class=line><span class=cl>replace github.com/some/DDD v1.2.3 <span class=o>=</span>&gt; replace github.com/some/DDD v1.1.1
</span></span><span class=line><span class=cl><span class=c1># 2. 换源</span>
</span></span><span class=line><span class=cl>replace github.com/some/DDD v1.2.3 <span class=o>=</span>&gt; replace mycloud.com/some/DDD v1.1.1
</span></span></code></pre></div><h2 id=04-go-channels--concurrency>04 Go Channels & Concurrency<a hidden class=anchor aria-hidden=true href=#04-go-channels--concurrency>#</a></h2><h3 id=41-goroutines-协程>4.1 Goroutines 协程<a hidden class=anchor aria-hidden=true href=#41-goroutines-协程>#</a></h3><p>Goroutine 很简单，使用 <code>go f(x, y, z)</code> 即可异步执行，Goroutine 运行在同一个地址空间，因此对共享内存的访问必须同步。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GO data-lang=GO><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>z</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//... }
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>f</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>z</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=42-channels-管道通道>4.2 Channels 管道/通道<a hidden class=anchor aria-hidden=true href=#42-channels-管道通道>#</a></h3><p>通道是一种类型化的管道，您可以通过它使用通道运算符 <code>&lt;-</code> 发送和接收值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Channel 必须先创建
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 向通道发送数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>v</span>    <span class=c1>// Send v to channel ch.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 从通道读取数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>v</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span>  <span class=c1>// Receive from ch, and
</span></span></span><span class=line><span class=cl><span class=c1></span>           <span class=c1>// assign value to v.
</span></span></span></code></pre></div><ul><li>默认向通道发送和接收数据时阻塞，直到发送/接收完成</li><li>从未初始化的通道（nil）读取数据，将死锁</li></ul><h3 id=43-buffer-channels-缓冲通道>4.3 Buffer Channels 缓冲通道<a hidden class=anchor aria-hidden=true href=#43-buffer-channels-缓冲通道>#</a></h3><p>通道可以缓冲，创建通道时指定缓冲大小即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span></code></pre></div><p>普通通道默认阻塞，而缓冲通道只会在两种情况下阻塞：</p><ol><li>缓冲通道满时，发送阻塞</li><li>缓冲通道为空时，接收阻塞</li></ol><h3 id=44-channel-range--close>4.4 Channel Range & Close<a hidden class=anchor aria-hidden=true href=#44-channel-range--close>#</a></h3><p>通道可以使用 Range 来遍历接收：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// v, ok := &lt;- ch
</span></span></span><span class=line><span class=cl><span class=c1>// ok is false if ch has closed, or it is true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这里只推送了 5 个，所以需要主动关闭通道
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>go</span> <span class=nf>f</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// print
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>发送者可以主动关闭通道（接收者不行）， 当然，通道和文件不同，通常不用关闭。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>ch</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 关闭 ch，以防 x 小于 ch 缓冲长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=45-select-多通道监听>4.5 Select 多通道监听<a hidden class=anchor aria-hidden=true href=#45-select-多通道监听>#</a></h3><p>上述 Channel 和 Buffer Channel 都是针对单个通道的，如果要同时接收多个通道的信息，需要使用 <code>Select</code>，它类似 switch 语法，只不过它用于通道监听。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>ch1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>// do sth.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>case</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>ch2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>// do sth.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当 Select 监听的其中一个通道接收到数据，对执行对应的 case；如果同时多个通道都接收到消息，那么会<strong>随机</strong>选择一个（是不是有点类似 C 的 select、poll、epoll？）</p><p>Select 默认是阻塞等待的，但是加上 <code>default</code> 之后，它就变成类似 <code>try lock</code> 的非阻塞监听，通道有数据时读取，如果没有直接往下执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>ch</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do sth.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 从 ch 接收时会阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=46-只读只写限制>4.6 只读、只写限制<a hidden class=anchor aria-hidden=true href=#46-只读只写限制>#</a></h3><p>声明 Channel 时，可以限制它的读写权限：</p><ul><li><code>&lt;-chan T</code>：只读通道</li><li><code>chan&lt;- T</code>：只写通道</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>readOnly</span><span class=p>(</span><span class=nx>ch</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ch can only be read from.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>wirteOnly</span><span class=p>(</span><span class=nx>ch</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ch can only be write to.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>writeOnly</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>readOnly</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=05-锁>05 锁<a hidden class=anchor aria-hidden=true href=#05-锁>#</a></h2><h3 id=51-mutex-互斥锁>5.1 Mutex 互斥锁<a hidden class=anchor aria-hidden=true href=#51-mutex-互斥锁>#</a></h3><p>互斥锁（Mutex，全称 Mutual Exclusion）是一种同步机制，用于确保在任意时刻只有一个线程能够访问共享资源，从而避免多个线程同时修改相同的数据造成的问题。</p><p>Mutex 有如下两个方法：</p><ul><li><code>sync.Lock()</code>：加锁</li><li><code>sync.Unlock()</code>：解锁</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>sharedResource</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>mutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>inc</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 加锁
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span> <span class=c1>// 在函数结束时释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// 访问或修改共享资源
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sharedResource</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// go inc() ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=52-rwmutex-读写锁>5.2 RWMutex 读写锁<a hidden class=anchor aria-hidden=true href=#52-rwmutex-读写锁>#</a></h3><p>RWMutex 读写互斥锁，它相比于普通的互斥锁 Mutex 提供了更灵活的读写控制。在 Go 语言中，RWMutex 可以同时允许多个 goroutine 获取读取锁，但在写入锁被获取时，所有的读取和写入操作都会被阻塞。</p><p>除了有 Mutex 一样的 <code>Lock</code> 和 <code>Unlock</code> 方法，还有读写锁：</p><ul><li><code>sync.RLock()</code>：加读锁，多个 goroutine 可同时加锁，不影响读。但如果被 Lock，则 RLock 不能再加锁，将被阻塞</li><li><code>sync.RUnlock()</code>：解锁</li></ul><h2 id=references>REFERENCES<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p>[1] 官方文档. <a href=https://tour.golang.org/>https://tour.golang.org/</a>.<br>[2] 极客兔兔. Go 语言简明教程[DB/OL]. <a href=https://geektutu.com/post/quick-golang.html>https://geektutu.com/post/quick-golang.html</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.springx.fun/tags/tech/>Tech</a></li><li><a href=https://blog.springx.fun/tags/golang/>Golang</a></li></ul><nav class=paginav><a class=prev href=https://blog.springx.fun/posts/tech/mysql-distinct/><span class=title>« Prev</span><br><span>MySQL 去重之 distinct</span>
</a><a class=next href=https://blog.springx.fun/posts/others/learning-programming-is-different-from-learning-a-programming-language/><span class=title>Next »</span><br><span>Learning programming is different from learning a programming language</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share GO 语言快速入门 on x" href="https://x.com/intent/tweet/?text=GO%20%e8%af%ad%e8%a8%80%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&amp;url=https%3a%2f%2fblog.springx.fun%2fposts%2ftech%2fgolang-quick-guide%2f&amp;hashtags=tech%2cgolang"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GO 语言快速入门 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.springx.fun%2fposts%2ftech%2fgolang-quick-guide%2f&amp;title=GO%20%e8%af%ad%e8%a8%80%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&amp;summary=GO%20%e8%af%ad%e8%a8%80%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&amp;source=https%3a%2f%2fblog.springx.fun%2fposts%2ftech%2fgolang-quick-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GO 语言快速入门 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.springx.fun%2fposts%2ftech%2fgolang-quick-guide%2f&title=GO%20%e8%af%ad%e8%a8%80%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GO 语言快速入门 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.springx.fun%2fposts%2ftech%2fgolang-quick-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GO 语言快速入门 on whatsapp" href="https://api.whatsapp.com/send?text=GO%20%e8%af%ad%e8%a8%80%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%20-%20https%3a%2f%2fblog.springx.fun%2fposts%2ftech%2fgolang-quick-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GO 语言快速入门 on telegram" href="https://telegram.me/share/url?text=GO%20%e8%af%ad%e8%a8%80%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&amp;url=https%3a%2f%2fblog.springx.fun%2fposts%2ftech%2fgolang-quick-guide%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GO 语言快速入门 on ycombinator" href="https://news.ycombinator.com/submitlink?t=GO%20%e8%af%ad%e8%a8%80%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&u=https%3a%2f%2fblog.springx.fun%2fposts%2ftech%2fgolang-quick-guide%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.springx.fun/>酸辣土豆丝 iCS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>